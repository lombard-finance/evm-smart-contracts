import { ethers } from 'hardhat';
import { encode } from '../test/helpers';

const valsetPayload: string =
  'SqsdbwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJxOkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBCHt6TpXpa1Uen16sH3zVy/PKsVBfydTRa/QKvQr1WaIVflIEyEP6VkJaj+NbGLJswHu/4PNE4RMWHps8j07y88AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEEEIRQtuSJrl3ya5su+ABTFOwTmuDBO8axmKJcMrXnTdVCb8uPrj1n0TOWQVXXgRl8acK8VR2YNQHmFrkUttQZpgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQQSFFb99a6Por7dm388KgpzwOLeVftb0EN2rpV399dRN5eQiYchsVFZk4OgF/p9kdj5LKaaOvouB9ruP2+CwiCB3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBNx+0WD9L5Dl7FhFRDYd4uhN4nZ21ZSw0qqSio3dOXViVz4WbzC6lXX9So2emDEJhWmSwDn6IB+ylpIqpWLdm0YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEEEUFKtRfkaA6VhFsY4s8tFybn1F4mNJ1+lE/sBsxW+c897PoVB1NLbP4bWT/7YLwIYfTzXqfvDXZPC3cy8gVcecgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQQSUdg9FCGF6p/8sdFNIe1aQ76v3MNSccl+xoFXYcUNgbBxiZgUvT4kdzRo3RmCiLV2NRAH0ubeQHEGDHen/ZkcTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB';
const signatures = [
  'MEUCIQCdeJaEXBvZgROFUjC64A99SNL/y7A3StZ4sS3zLFuzbwIgFx8JRN5U7SvXrJLngMXrogBqAjWKaXgQ2E6n4Edtyl8=',
  '',
  'MEQCIGVby6AHloHoHW/g7wwNcIt3wAzbJ34nwzG9dfxCtazCAiAB3ir5pmwAd+9gI5uDz/iqXvaLdjkL7QtjYQ9ln1bQOQ==',
  'MEQCIFrK/we6RQ9vdrMeK8coDbIBLqzMj/JBJ8c6jXlb6zSOAiBS1YExq2I13DD7vElJtGzf0fVcgtpw0W48QX6CZVuHgA==',
  'MEQCIG/7KbvUvqYqwZmov3rvIBB6z0ZHu4wwyfQuznIjRgykAiAYqXrFw84cGd27VLTv9O1xoCzaB/mcKb4tb4S2Y1CXzg=='
];

async function main() {
  const ethSigs = signatures
    .map(b64sig => {
      const d = Buffer.from(b64sig, 'base64');
      return `0x${d.toString('hex')}`;
    })
    .map(sig => {
      let rawSig = ethers.getBytes(sig);

      // Extract R and S from the serialized signature
      // The serialized format is: 0x30 <length> 0x02 <length-of-R> <R> 0x02 <length-of-S> <S>
      let rStart = 4; // Skip the first 4 bytes (0x30, total length, 0x02, R length)
      let rLength = rawSig[3];

      // skip 0x00
      if (rawSig[4] == 0) {
        rStart += 1;
        rLength -= 1;
      }
      const sStart = rStart + rLength + 2; // Skip R and 0x02
      const sLength = rawSig[rStart + rLength + 1];

      // Copy R and S into proof, padding to 32 bytes each
      const proof: Uint8Array = new Uint8Array(64);
      proof.set(rawSig.slice(rStart, rStart + rLength), 32 - rLength);
      proof.set(rawSig.slice(sStart, sStart + sLength), 64 - sLength);

      return ethers.hexlify(proof);
    });

  const proof = encode(['bytes[]'], [ethSigs]);

  const consortium = await ethers.getContractAt('Consortium', '0xf9c3D4e6C2a8F0a2E6aB7026cA2060b204585447');

  const p = '0x' + Buffer.from(valsetPayload, 'base64').toString('hex');

  const tx = await consortium.setNextValidatorSet(p, proof);
  console.log(tx);
}

main().catch(error => {
  console.error(error);
  process.exitCode = 1;
});
